{"version":3,"sources":["html_cljs/hooks.cljs"],"mappings":";;;AAYA,AAAA,AAAMA,AAAWC;AAAjB,AACE,AAAMC,AAAM,AAACC,AAAKF;AAAlB,AACE,AAAKI;AAAL,AAAA,AAAA,AAAAD,AACIF,AACD,AAAKI;AAAL,AACE,AAACC,AAAML,AAAMI;;AACb,AAACE,AAAaH;;;;AAEvB,AAAA,AAAMI;AAAN,AACE,AAAKJ;AAAL,AAAA;AAAA,AACG,AAAAK,AAAA,AAAAN,AAAEC;AAAF,AAAA,AAAAK,AAAAA,AAAA,AAAAA,AAAA","names":["html-cljs.hooks/use-state","init","state","cljs.core.atom","cljs.core/deref","vdom-state","swap-state","cljs.core.swap_BANG_","html_cljs.html.refresh","html-cljs.hooks/use-dom-el","fexpr__29059"],"sourcesContent":["(ns html-cljs.hooks\n  \"all the hooks for this project.\n  \n  a hook is used with the cmp macro. A hook is a function that accepts any\n  number of params that the user supplies and returns a function that accepts\n  the vdom atom as its sole argument. The return value of that is the\n  user facing value that is returned in the hook-calls part of the component\n  creation. This is so the vdom-state atom may be passed in and used by the\n  hook without the user ever knowing about the inner workings/lifecycle of the\n  library.\"\n  (:require [html-cljs.html :as html]))\n\n(defn use-state [init]\n  (let [state (atom init)]\n    (fn [vdom-state]\n      [@state\n       (fn [swap-state]\n         (swap! state swap-state)\n         (html/refresh vdom-state))])))\n\n(defn use-dom-el []\n  (fn [vdom-state]\n    #(@vdom-state :el)))\n"]}