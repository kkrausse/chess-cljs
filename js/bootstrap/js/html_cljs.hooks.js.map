{"version":3,"sources":["html_cljs/hooks.cljs"],"mappings":";AAeA,AAAA,AAAMA,AAAWC;AAAjB,AACE,AAAMC,AAAa,AAAA,AAAA,AAAA,AAAA,AAACC;AACdC,AAAW,AAACC,AAAKH;AADvB,AAEE,AAAKI;AAAL,AACE,AAAI,AAAA,AAAAC,AAACC,AAAGJ,AAAWF;AACjB,AAACO,AAAOL,AAAWE;;AADrB;;AADF,AAGG;AAAA,AAAA,AAAAC,AAAQH;AACR,AAAKM;AAAL,AACE,AAACC,AAAMP,AAAWM;;AAClB,AAACE,AAAkBX;;;;AAE5B,AAAA,AAAMY,AAAYZ;AAAlB,AACE,AAAMa,AAAY,AAAA,AAACT;AACbU,AAAa,AAAA,AAACV;AADpB,AAEE;AAAA,AACE,AAAKW;AAAL,AACE,AAAI,AAAA,AAAAT,AAACU,AAAKH;AACR,AACE,AAACI,AAAmBjB,AAAI;AAAA,AAAO,AAACQ,AAAOM,AAAa,AAACC,AAAAA,AAAAA;;;AACrD,AAACG,AAAqBlB,AAAI;AAAA,AAAO,AAAI,AAAA,AAAA,AAAAM,AAAA,AAAQQ;AACV,AAAAK,AAAA,AAAAb,AAAEQ;AAAF,AAAA,AAAAK,AAAAA,AAAAA;;AADF;;;;AAEjC,AAAA,AAACX,AAAOK;;AALZ;;;;;AAOR,AAAKO,AACH,AAAAC;AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAuCtB;AAAvCwB,AAAA,AAAAF,AACiDtB;AADjDyB,AAAA,AAAAH,AAEgCT;AAFhC,AAAA,AAASgB;AAAT,AAAA,AAAAH,AAAA,AAAAH,AAAA;AAAA,AAAAI,AAAAD,AAAA,AAAA,AAAqBI;AAArB,AAAAH,AAAAD,AAAA,AAAA,AAA6BK;AAA7BH,AAAA,AAAAJ,AAAA;AAAA,AAAAG,AAAAC,AAAA,AAAA,AACqBI;AADrB,AAAAL,AAAAC,AAAA,AAAA,AACkCK;AADlC,AAAAR,AAEoBS;AAFpB,AAGQ,AAAMC,AAAY;AAAA,AACE,AAAI,AAAA,AAAM,AAACH,AAAAA,AAAAA;AACT,AAAAI,AACE,AAAKC;AAAL,AAAQ,AAACC,AACC;AAAA,AAAO,AAACP,AAAAA,AAAAA,AAAQQ,AAAAA;AAAMV;;AAFlC,AAAA,AAAAO,AAAAA,AAACH,AAAAA,AAAAA;;AADH;;;AAIdO,AAAW;AAAA,AAAO,AAAI,AAAA,AAAA,AAAO,AAACR,AAAAA,AAAAA;AACV,AAAI,AAACS,AAAiB,AAACT,AAAAA,AAAAA;;AACnB,AAAAU,AAAc,AAAKL;AAAL,AAAA;;AAAd,AAAA,AAAAK,AAAAA,AAACT,AAAAA,AAAAA;;AAFP;;;AAGlBU,AAAO;AAAA,AACE,AAAI,AAAA,AAAM,AAACX,AAAAA,AAAAA;AAAe,AAACG;;AAAa,AAACK;;;AATxD,AAUE,AAAAI,AAAY;AAAA,AACE,AAACT;;AACDK;;AAFd,AAAA,AAAAI,AAAAA,AAACV,AAAAA,AAAAA;;AAVH,AAaG,AAACJ,AAAAA,AAAAA,AAASa","names":["html-cljs.hooks/use-state","clc","zeroth-value","cljs.core.symbol","state-atom","cljs.core.atom","initial-state","cljs.core/deref","cljs.core._EQ_","cljs.core/reset!","swap","cljs.core.swap_BANG_","html-cljs.lifecycle/refresh","html-cljs.hooks/use-effect","initialized","cleanup-func","user-func","cljs.core/not","html-cljs.lifecycle/on-mount","html-cljs.lifecycle/on-destroy","fexpr__26652","html-cljs.hooks/use-interval","clc__26110__auto__","hooked-use-state26653","hooked-use-state26654","hooked-use-effect26655","vec__26656","cljs.core.nth","vec__26659","interval","get-cnt","set-cnt","get-interval","set-interval","set-effect","start-timer","G__26662","_","js/setInterval","cljs.core/inc","stop-timer","js/clearInterval","G__26663","toggle","G__26664"],"sourcesContent":["(ns html-cljs.hooks\n  \"all the hooks for this project.\n  \n  a hook is used with the cmp macro. A hook is a function that accepts any\n  number of params that the user supplies and returns a function that accepts\n  the vdom atom as its sole argument. The return value of that is the\n  user facing value that is returned in the hook-calls part of the component\n  creation. This is so the vdom-state atom may be passed in and used by the\n  hook without the user ever knowing about the inner workings/lifecycle of the\n  library.\"\n  (:require-macros [html-cljs.hooks :refer [mkhook]])\n  (:require [html-cljs.html :as html]\n            [html-cljs.lifecycle :as lifecycle]))\n\n\n(defn use-state [clc]\n  (let [zeroth-value (symbol 'html-cljs.hooks 'rarespare)\n        state-atom (atom zeroth-value)]\n    (fn [initial-state]\n      (if (= @state-atom zeroth-value)\n        (reset! state-atom initial-state))\n      [(fn [] @state-atom)\n       (fn [swap]\n         (swap! state-atom swap)\n         (lifecycle/refresh clc))])))\n\n(defn use-effect [clc]\n  (let [initialized (atom false)\n        cleanup-func (atom nil)]\n    (fn []\n      (fn [user-func]\n        (if (not @initialized)\n          (do\n            (lifecycle/on-mount clc (fn [] (reset! cleanup-func (user-func))))\n            (lifecycle/on-destroy clc (fn [] (if (some? @cleanup-func)\n                                               (@cleanup-func))))\n            (reset! initialized true)))))))\n\n(def use-interval\n  (mkhook [interval] [[get-cnt set-cnt] (use-state 0)\n                      [get-interval set-interval] (use-state nil)\n                      set-effect (use-effect)]\n          (let [start-timer (fn []\n                              (if (nil? (get-interval))\n                                (set-interval\n                                  (fn [_] (js/setInterval\n                                            (fn [] (set-cnt inc)) interval)))))\n                stop-timer (fn [] (if (some? (get-interval))\n                                    (do (js/clearInterval (get-interval))\n                                        (set-interval (fn [_] nil)))))\n                toggle (fn []\n                         (if (nil? (get-interval)) (start-timer) (stop-timer)))]\n            (set-effect (fn []\n                          (start-timer)\n                          stop-timer))\n            [(get-cnt) toggle])))\n"]}