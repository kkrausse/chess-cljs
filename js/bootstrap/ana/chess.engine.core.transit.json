["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","chess/engine/core.cljs","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",22],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader"],"~:shadow/protocol-prefixes",["~#set",["chess$engine$core$Engine$"]],"~:use-macros",["^ ","~$match","~$chess.utils","~$plusminus","^?"],"~:excludes",["^<",[]],"~:name","~$chess.engine.core","~:imports",null,"~:requires",["^ ","~$html-cljs.hooks","^F","~$hooks","^F","^?","^?","~$cljs.core","^H","~$goog","^I"],"~:seen",["^<",["~:require"]],"~:uses",["^ ","~$zip","^?","^>","^?","^@","^?"],"~:defs",["^ ","~$empty-row",["^ ","^B","~$chess.engine.core/empty-row","^3","chess/engine/core.cljs","^4",14,"^5",3,"^6",14,"^7",17,"^2",["^ ","^3","chess/engine/core.cljs","^4",14,"^5",8,"^6",14,"^7",17],"~:tag","~$cljs.core/LazySeq"],"~$Engine",["^ ","^2",["^ ","~:protocol-symbol",true,"^3","chess/engine/core.cljs","^7",20,"^5",14,"^4",28,"~:protocol-info",["^ ","~:methods",["^ ","~$apply-move",[["~$this","~$board","~$move"]],"~$possible-moves",[["^X","^Y","~$color"]],"~$best-move",[["^X","^Y","^10"]]]],"^6",28,"~:sigs",["^ ","~:apply-move",["^ ","^B","^W","~:arglists",["~#list",[["^X","^Y","^Z"]]],"~:doc","applies the move where move is of the form [[fromi fromj] [toi toj]...]\n                          in the case of castling, theres more than one move, thus the '...'"],"~:possible-moves",["^ ","^B","^[","^14",["^15",[["^X","^Y","^10"]]],"^16","returns a sequence of possible moves for\n                                     the given color. If empty, that color just\n                                     lost"],"~:best-move",["^ ","^B","^11","^14",["^15",[["^X","^Y","^10"]]],"^16","the ai's decision of the best possible move. If\n                                nil, then the other player won"]],"^16","interface for the chess ai. board is indexed like this:\n  board[i][j] is like\n    i = [8 7 6 ...], so reversed and indexed at zero,\n    j = [a b c ...], so normal, but indexed at zero.\n  so, if you're looking at the board and you are playing white, the top left is\n  0,0 and moving one square closer to the white side is 1,0","~:jsdoc",["^15",["@interface"]]],"^T",true,"^B","~$chess.engine.core/Engine","^3","chess/engine/core.cljs","^7",20,"^5",1,"^4",28,"^U",["^ ","^V",["^ ","^W",[["^X","^Y","^Z"]],"^[",[["^X","^Y","^10"]],"^11",[["^X","^Y","^10"]]]],"~:info",null,"^6",28,"^Q","~$any","^12",["^ ","^13",["^ ","^B","^W","^14",["^15",[["^X","^Y","^Z"]]],"^16","applies the move where move is of the form [[fromi fromj] [toi toj]...]\n                          in the case of castling, theres more than one move, thus the '...'"],"^17",["^ ","^B","^[","^14",["^15",[["^X","^Y","^10"]]],"^16","returns a sequence of possible moves for\n                                     the given color. If empty, that color just\n                                     lost"],"^18",["^ ","^B","^11","^14",["^15",[["^X","^Y","^10"]]],"^16","the ai's decision of the best possible move. If\n                                nil, then the other player won"]],"~:impls",["^<",["~$chess.engine.local-engine/t_chess$engine$local_engine8902"]],"^16","interface for the chess ai. board is indexed like this:\n  board[i][j] is like\n    i = [8 7 6 ...], so reversed and indexed at zero,\n    j = [a b c ...], so normal, but indexed at zero.\n  so, if you're looking at the board and you are playing white, the top left is\n  0,0 and moving one square closer to the white side is 1,0","^19",["^15",["@interface"]]],"~$main-row",["^ ","~:protocol-inline",null,"^2",["^ ","^3","chess/engine/core.cljs","^4",6,"^5",9,"^6",6,"^7",17,"^14",["^15",["~$quote",["^15",[["^10"]]]]]],"^B","~$chess.engine.core/main-row","^3","chess/engine/core.cljs","^7",17,"~:method-params",["^15",[["^10"]]],"~:protocol-impl",null,"~:arglists-meta",["^15",[null,null]],"^5",3,"~:variadic?",false,"^4",6,"~:ret-tag","^R","^6",6,"~:max-fixed-arity",1,"~:fn-var",true,"^14",["^15",["^1A",["^15",[["^10"]]]]]],"~$pawn-row",["^ ","^1@",null,"^2",["^ ","^3","chess/engine/core.cljs","^4",10,"^5",9,"^6",10,"^7",17,"^14",["^15",["^1A",["^15",[["^10"]]]]]],"^B","~$chess.engine.core/pawn-row","^3","chess/engine/core.cljs","^7",17,"^1C",["^15",[["^10"]]],"^1D",null,"^1E",["^15",[null,null]],"^5",3,"^1F",false,"^4",10,"^1G","^R","^6",10,"^1H",1,"^1I",true,"^14",["^15",["^1A",["^15",[["^10"]]]]]],"~$init-board",["^ ","^B","~$chess.engine.core/init-board","^3","chess/engine/core.cljs","^4",5,"^5",1,"^6",5,"^7",16,"^2",["^ ","^3","chess/engine/core.cljs","^4",5,"^5",6,"^6",5,"^7",16],"^Q","^R"],"^[",["^ ","^1@",null,"^2",["^ ","^3","chess/engine/core.cljs","^4",38,"^5",4,"^6",38,"^7",18,"~:protocol","^1:","^16","returns a sequence of possible moves for\n                                     the given color. If empty, that color just\n                                     lost","^14",["^15",["^1A",["^15",[["^X","^Y","^10"]]]]]],"^1N","^1:","^B","~$chess.engine.core/possible-moves","^3","chess/engine/core.cljs","^7",18,"^1C",["^15",[["^X","^Y","^10"]]],"^1D",null,"^1E",["^15",[null,null]],"^5",1,"^1F",false,"^4",28,"^1G","^1<","^6",38,"^1H",3,"^1I",true,"^14",["^15",["^1A",["^15",[["^X","^Y","^10"]]]]],"^16","returns a sequence of possible moves for\n                                     the given color. If empty, that color just\n                                     lost"],"^W",["^ ","^1@",null,"^2",["^ ","^3","chess/engine/core.cljs","^4",35,"^5",4,"^6",35,"^7",14,"^1N","^1:","^16","applies the move where move is of the form [[fromi fromj] [toi toj]...]\n                          in the case of castling, theres more than one move, thus the '...'","^14",["^15",["^1A",["^15",[["^X","^Y","^Z"]]]]]],"^1N","^1:","^B","~$chess.engine.core/apply-move","^3","chess/engine/core.cljs","^7",14,"^1C",["^15",[["^X","^Y","^Z"]]],"^1D",null,"^1E",["^15",[null,null]],"^5",1,"^1F",false,"^4",28,"^1G","^1<","^6",35,"^1H",3,"^1I",true,"^14",["^15",["^1A",["^15",[["^X","^Y","^Z"]]]]],"^16","applies the move where move is of the form [[fromi fromj] [toi toj]...]\n                          in the case of castling, theres more than one move, thus the '...'"],"^11",["^ ","^1@",null,"^2",["^ ","^3","chess/engine/core.cljs","^4",41,"^5",4,"^6",41,"^7",13,"^1N","^1:","^16","the ai's decision of the best possible move. If\n                                nil, then the other player won","^14",["^15",["^1A",["^15",[["^X","^Y","^10"]]]]]],"^1N","^1:","^B","~$chess.engine.core/best-move","^3","chess/engine/core.cljs","^7",13,"^1C",["^15",[["^X","^Y","^10"]]],"^1D",null,"^1E",["^15",[null,null]],"^5",1,"^1F",false,"^4",28,"^1G","^1<","^6",41,"^1H",3,"^1I",true,"^14",["^15",["^1A",["^15",[["^X","^Y","^10"]]]]],"^16","the ai's decision of the best possible move. If\n                                nil, then the other player won"],"~$other-color",["^ ","^1@",null,"^2",["^ ","^3","chess/engine/core.cljs","^4",23,"^5",7,"^6",23,"^7",18,"^14",["^15",["^1A",["^15",[["^10"]]]]]],"^B","~$chess.engine.core/other-color","^3","chess/engine/core.cljs","^7",18,"^1C",["^15",[["^10"]]],"^1D",null,"^1E",["^15",[null,null]],"^5",1,"^1F",false,"^4",23,"^1G",["^<",["~$cljs.core/Keyword","~$clj-nil"]],"^6",23,"^1H",1,"^1I",true,"^14",["^15",["^1A",["^15",[["^10"]]]]]]],"~:require-macros",["^ ","^H","^H","^?","^?"],"~:cljs.analyzer/constants",["^ ","^J",["^<",["~:bishop","~:king","~:moved","~:color","~:white","~:queen","~:piece","~:knight","~:rook","~:pawn","~:black"]],"~:order",["^22","^1[","^1Z","^24","^23","^1X","^1Y","^21","^25","^26","^20"]],"~:flags",["^ ","^K",["^<",[]]],"~:js-deps",["^ "],"~:deps",["^I","^H","^F","^?"]]